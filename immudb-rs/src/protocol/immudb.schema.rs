// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Key {
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Permission {
    /// Database name
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// Permission, 1 - read permission, 2 - read+write permission, 254 - admin, 255 - sysadmin
    #[prost(uint32, tag = "2")]
    pub permission: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    /// Username
    #[prost(bytes = "vec", tag = "1")]
    pub user: ::prost::alloc::vec::Vec<u8>,
    /// List of permissions for the user
    #[prost(message, repeated, tag = "3")]
    pub permissions: ::prost::alloc::vec::Vec<Permission>,
    /// Name of the creator user
    #[prost(string, tag = "4")]
    pub createdby: ::prost::alloc::string::String,
    /// Time when the user was created
    #[prost(string, tag = "5")]
    pub createdat: ::prost::alloc::string::String,
    /// Flag indicating whether the user is active or not
    #[prost(bool, tag = "6")]
    pub active: bool,
    /// List of SQL privileges
    #[prost(message, repeated, tag = "7")]
    pub sql_privileges: ::prost::alloc::vec::Vec<SqlPrivilege>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlPrivilege {
    /// Database name
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// Privilege: SELECT, CREATE, INSERT, UPDATE, DELETE, DROP, ALTER
    #[prost(string, tag = "2")]
    pub privilege: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserList {
    /// List of users
    #[prost(message, repeated, tag = "1")]
    pub users: ::prost::alloc::vec::Vec<User>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateUserRequest {
    /// Username
    #[prost(bytes = "vec", tag = "1")]
    pub user: ::prost::alloc::vec::Vec<u8>,
    /// Login password
    #[prost(bytes = "vec", tag = "2")]
    pub password: ::prost::alloc::vec::Vec<u8>,
    /// Permission, 1 - read permission, 2 - read+write permission, 254 - admin
    #[prost(uint32, tag = "3")]
    pub permission: u32,
    /// Database name
    #[prost(string, tag = "4")]
    pub database: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserRequest {
    /// Username
    #[prost(bytes = "vec", tag = "1")]
    pub user: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChangePasswordRequest {
    /// Username
    #[prost(bytes = "vec", tag = "1")]
    pub user: ::prost::alloc::vec::Vec<u8>,
    /// Old password
    #[prost(bytes = "vec", tag = "2")]
    pub old_password: ::prost::alloc::vec::Vec<u8>,
    /// New password
    #[prost(bytes = "vec", tag = "3")]
    pub new_password: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoginRequest {
    /// Username
    #[prost(bytes = "vec", tag = "1")]
    pub user: ::prost::alloc::vec::Vec<u8>,
    /// User's password
    #[prost(bytes = "vec", tag = "2")]
    pub password: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoginResponse {
    /// Deprecated: use session-based authentication
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    /// Optional: additional warning message sent to the user (e.g. request to change the password)
    #[prost(bytes = "vec", tag = "2")]
    pub warning: ::prost::alloc::vec::Vec<u8>,
}
/// DEPRECATED
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AuthConfig {
    #[prost(uint32, tag = "1")]
    pub kind: u32,
}
/// DEPRECATED
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MtlsConfig {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OpenSessionRequest {
    /// Username
    #[prost(bytes = "vec", tag = "1")]
    pub username: ::prost::alloc::vec::Vec<u8>,
    /// Password
    #[prost(bytes = "vec", tag = "2")]
    pub password: ::prost::alloc::vec::Vec<u8>,
    /// Database name
    #[prost(string, tag = "3")]
    pub database_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OpenSessionResponse {
    /// Id of the new session
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// UUID of the server
    #[prost(string, tag = "2")]
    pub server_uuid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Precondition {
    #[prost(oneof = "precondition::Precondition", tags = "1, 2, 3")]
    pub precondition: ::core::option::Option<precondition::Precondition>,
}
/// Nested message and enum types in `Precondition`.
pub mod precondition {
    /// Only succeed if given key exists
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct KeyMustExistPrecondition {
        /// key to check
        #[prost(bytes = "vec", tag = "1")]
        pub key: ::prost::alloc::vec::Vec<u8>,
    }
    /// Only succeed if given key does not exists
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct KeyMustNotExistPrecondition {
        /// key to check
        #[prost(bytes = "vec", tag = "1")]
        pub key: ::prost::alloc::vec::Vec<u8>,
    }
    /// Only succeed if given key was not modified after given transaction
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct KeyNotModifiedAfterTxPrecondition {
        /// key to check
        #[prost(bytes = "vec", tag = "1")]
        pub key: ::prost::alloc::vec::Vec<u8>,
        /// transaction id to check against
        #[prost(uint64, tag = "2")]
        pub tx_id: u64,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Precondition {
        #[prost(message, tag = "1")]
        KeyMustExist(KeyMustExistPrecondition),
        #[prost(message, tag = "2")]
        KeyMustNotExist(KeyMustNotExistPrecondition),
        #[prost(message, tag = "3")]
        KeyNotModifiedAfterTx(KeyNotModifiedAfterTxPrecondition),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KeyValue {
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<KvMetadata>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Entry {
    /// Transaction id at which the target value was set (i.e. not the reference transaction id)
    #[prost(uint64, tag = "1")]
    pub tx: u64,
    /// Key of the target value (i.e. not the reference entry)
    #[prost(bytes = "vec", tag = "2")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// Value
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// If the request was for a reference, this field will keep information about the reference entry
    #[prost(message, optional, tag = "4")]
    pub referenced_by: ::core::option::Option<Reference>,
    /// Metadata of the target entry (i.e. not the reference entry)
    #[prost(message, optional, tag = "5")]
    pub metadata: ::core::option::Option<KvMetadata>,
    /// If set to true, this entry has expired and the value is not retrieved
    #[prost(bool, tag = "6")]
    pub expired: bool,
    /// Key's revision, in case of GetAt it will be 0
    #[prost(uint64, tag = "7")]
    pub revision: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Reference {
    /// Transaction if when the reference key was set
    #[prost(uint64, tag = "1")]
    pub tx: u64,
    /// Reference key
    #[prost(bytes = "vec", tag = "2")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// At which transaction the key is bound, 0 if reference is not bound and should read the most recent reference
    #[prost(uint64, tag = "3")]
    pub at_tx: u64,
    /// Metadata of the reference entry
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<KvMetadata>,
    /// Revision of the reference entry
    #[prost(uint64, tag = "5")]
    pub revision: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Op {
    #[prost(oneof = "op::Operation", tags = "1, 2, 3")]
    pub operation: ::core::option::Option<op::Operation>,
}
/// Nested message and enum types in `Op`.
pub mod op {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        /// Modify / add simple KV value
        #[prost(message, tag = "1")]
        Kv(super::KeyValue),
        /// Modify / add sorted set entry
        #[prost(message, tag = "2")]
        ZAdd(super::ZAddRequest),
        /// Modify / add reference
        #[prost(message, tag = "3")]
        Ref(super::ReferenceRequest),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecAllRequest {
    /// List of operations to perform
    #[prost(message, repeated, tag = "1")]
    pub operations: ::prost::alloc::vec::Vec<Op>,
    /// If set to true, do not wait for indexing to process this transaction
    #[prost(bool, tag = "2")]
    pub no_wait: bool,
    /// Preconditions to check
    #[prost(message, repeated, tag = "3")]
    pub preconditions: ::prost::alloc::vec::Vec<Precondition>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Entries {
    /// List of entries
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<Entry>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZEntry {
    /// Name of the sorted set
    #[prost(bytes = "vec", tag = "1")]
    pub set: ::prost::alloc::vec::Vec<u8>,
    /// Referenced key
    #[prost(bytes = "vec", tag = "2")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// Referenced entry
    #[prost(message, optional, tag = "3")]
    pub entry: ::core::option::Option<Entry>,
    /// Sorted set element's score
    #[prost(double, tag = "4")]
    pub score: f64,
    /// At which transaction the key is bound,
    /// 0 if reference is not bound and should read the most recent reference
    #[prost(uint64, tag = "5")]
    pub at_tx: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZEntries {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<ZEntry>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScanRequest {
    /// If not empty, continue scan at (when inclusiveSeek == true)
    /// or after (when inclusiveSeek == false) that key
    #[prost(bytes = "vec", tag = "1")]
    pub seek_key: ::prost::alloc::vec::Vec<u8>,
    /// stop at (when inclusiveEnd == true)
    /// or before (when inclusiveEnd == false) that key
    #[prost(bytes = "vec", tag = "7")]
    pub end_key: ::prost::alloc::vec::Vec<u8>,
    /// search for entries with this prefix only
    #[prost(bytes = "vec", tag = "2")]
    pub prefix: ::prost::alloc::vec::Vec<u8>,
    /// If set to true, sort items in descending order
    #[prost(bool, tag = "3")]
    pub desc: bool,
    /// maximum number of entries to get, if not specified, the default value is used
    #[prost(uint64, tag = "4")]
    pub limit: u64,
    /// If non-zero, only require transactions up to this transaction to be
    /// indexed, newer transaction may still be pending
    #[prost(uint64, tag = "5")]
    pub since_tx: u64,
    /// Deprecated: If set to true, do not wait for indexing to be done before finishing this call
    #[prost(bool, tag = "6")]
    pub no_wait: bool,
    /// If set to true, results will include seekKey
    #[prost(bool, tag = "8")]
    pub inclusive_seek: bool,
    /// If set to true, results will include endKey if needed
    #[prost(bool, tag = "9")]
    pub inclusive_end: bool,
    /// Specify the initial entry to be returned by excluding the initial set of entries
    #[prost(uint64, tag = "10")]
    pub offset: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KeyPrefix {
    #[prost(bytes = "vec", tag = "1")]
    pub prefix: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EntryCount {
    #[prost(uint64, tag = "1")]
    pub count: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Signature {
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TxHeader {
    /// Transaction ID
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// State value (Accumulative Hash - Alh) of the previous transaction
    #[prost(bytes = "vec", tag = "2")]
    pub prev_alh: ::prost::alloc::vec::Vec<u8>,
    /// Unix timestamp of the transaction (in seconds)
    #[prost(int64, tag = "3")]
    pub ts: i64,
    /// Number of entries in a transaction
    #[prost(int32, tag = "4")]
    pub nentries: i32,
    /// Entries Hash - cumulative hash of all entries in the transaction
    #[prost(bytes = "vec", tag = "5")]
    pub e_h: ::prost::alloc::vec::Vec<u8>,
    /// Binary linking tree transaction ID
    /// (ID of last transaction already in the main Merkle Tree)
    #[prost(uint64, tag = "6")]
    pub bl_tx_id: u64,
    /// Binary linking tree root (Root hash of the Merkle Tree)
    #[prost(bytes = "vec", tag = "7")]
    pub bl_root: ::prost::alloc::vec::Vec<u8>,
    /// Header version
    #[prost(int32, tag = "8")]
    pub version: i32,
    /// Transaction metadata
    #[prost(message, optional, tag = "9")]
    pub metadata: ::core::option::Option<TxMetadata>,
}
/// TxMetadata contains metadata set to whole transaction
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TxMetadata {
    /// Entry expiration information
    #[prost(uint64, tag = "1")]
    pub truncated_tx_id: u64,
    /// Extra data
    #[prost(bytes = "vec", tag = "2")]
    pub extra: ::prost::alloc::vec::Vec<u8>,
}
/// LinearProof contains the linear part of the proof (outside the main Merkle Tree)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LinearProof {
    /// Starting transaction of the proof
    #[prost(uint64, tag = "1")]
    pub source_tx_id: u64,
    /// End transaction of the proof
    #[prost(uint64, tag = "2")]
    pub target_tx_id: u64,
    /// List of terms (inner hashes of transaction entries)
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub terms: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// LinearAdvanceProof contains the proof of consistency between the consumed part of the older linear chain
/// and the new Merkle Tree
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinearAdvanceProof {
    /// terms for the linear chain
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub linear_proof_terms: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// inclusion proofs for steps on the linear chain
    #[prost(message, repeated, tag = "2")]
    pub inclusion_proofs: ::prost::alloc::vec::Vec<InclusionProof>,
}
/// DualProof contains inclusion and consistency proofs for dual Merkle-Tree + Linear proofs
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DualProof {
    /// Header of the source (earlier) transaction
    #[prost(message, optional, tag = "1")]
    pub source_tx_header: ::core::option::Option<TxHeader>,
    /// Header of the target (latter) transaction
    #[prost(message, optional, tag = "2")]
    pub target_tx_header: ::core::option::Option<TxHeader>,
    /// Inclusion proof of the source transaction hash in the main Merkle Tree
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub inclusion_proof: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Consistency proof between Merkle Trees in the source and target transactions
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub consistency_proof: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Accumulative hash (Alh) of the last transaction that's part of the target Merkle Tree
    #[prost(bytes = "vec", tag = "5")]
    pub target_bl_tx_alh: ::prost::alloc::vec::Vec<u8>,
    /// Inclusion proof of the targetBlTxAlh in the target Merkle Tree
    #[prost(bytes = "vec", repeated, tag = "6")]
    pub last_inclusion_proof: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Linear proof starting from targetBlTxAlh to the final state value
    #[prost(message, optional, tag = "7")]
    pub linear_proof: ::core::option::Option<LinearProof>,
    /// Proof of consistency between some part of older linear chain and newer Merkle Tree
    #[prost(message, optional, tag = "8")]
    pub linear_advance_proof: ::core::option::Option<LinearAdvanceProof>,
}
/// DualProofV2 contains inclusion and consistency proofs
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DualProofV2 {
    /// Header of the source (earlier) transaction
    #[prost(message, optional, tag = "1")]
    pub source_tx_header: ::core::option::Option<TxHeader>,
    /// Header of the target (latter) transaction
    #[prost(message, optional, tag = "2")]
    pub target_tx_header: ::core::option::Option<TxHeader>,
    /// Inclusion proof of the source transaction hash in the main Merkle Tree
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub inclusion_proof: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Consistency proof between Merkle Trees in the source and target transactions
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub consistency_proof: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tx {
    /// Transaction header
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<TxHeader>,
    /// Raw entry values
    #[prost(message, repeated, tag = "2")]
    pub entries: ::prost::alloc::vec::Vec<TxEntry>,
    /// KV entries in the transaction (parsed)
    #[prost(message, repeated, tag = "3")]
    pub kv_entries: ::prost::alloc::vec::Vec<Entry>,
    /// Sorted Set entries in the transaction (parsed)
    #[prost(message, repeated, tag = "4")]
    pub z_entries: ::prost::alloc::vec::Vec<ZEntry>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TxEntry {
    /// Raw key value (contains 1-byte prefix for kind of the key)
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// Value hash
    #[prost(bytes = "vec", tag = "2")]
    pub h_value: ::prost::alloc::vec::Vec<u8>,
    /// Value length
    #[prost(int32, tag = "3")]
    pub v_len: i32,
    /// Entry metadata
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<KvMetadata>,
    /// value, must be ignored when len(value) == 0 and vLen > 0.
    /// Otherwise sha256(value) must be equal to hValue.
    #[prost(bytes = "vec", tag = "5")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KvMetadata {
    /// True if this entry denotes a logical deletion
    #[prost(bool, tag = "1")]
    pub deleted: bool,
    /// Entry expiration information
    #[prost(message, optional, tag = "2")]
    pub expiration: ::core::option::Option<Expiration>,
    /// If set to true, this entry will not be indexed and will only be accessed through GetAt calls
    #[prost(bool, tag = "3")]
    pub non_indexable: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Expiration {
    /// Entry expiration time (unix timestamp in seconds)
    #[prost(int64, tag = "1")]
    pub expires_at: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifiableTx {
    /// Transaction to verify
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<Tx>,
    /// Proof for the transaction
    #[prost(message, optional, tag = "2")]
    pub dual_proof: ::core::option::Option<DualProof>,
    /// Signature for the new state value
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<Signature>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifiableTxV2 {
    /// Transaction to verify
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<Tx>,
    /// Proof for the transaction
    #[prost(message, optional, tag = "2")]
    pub dual_proof: ::core::option::Option<DualProofV2>,
    /// Signature for the new state value
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<Signature>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifiableEntry {
    /// Entry to verify
    #[prost(message, optional, tag = "1")]
    pub entry: ::core::option::Option<Entry>,
    /// Transaction to verify
    #[prost(message, optional, tag = "2")]
    pub verifiable_tx: ::core::option::Option<VerifiableTx>,
    /// Proof for inclusion of the entry within the transaction
    #[prost(message, optional, tag = "3")]
    pub inclusion_proof: ::core::option::Option<InclusionProof>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InclusionProof {
    /// Index of the leaf for which the proof is generated
    #[prost(int32, tag = "1")]
    pub leaf: i32,
    /// Width of the tree at the leaf level
    #[prost(int32, tag = "2")]
    pub width: i32,
    /// Proof terms (selected hashes from the tree)
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub terms: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRequest {
    /// List of KV entries to set
    #[prost(message, repeated, tag = "1")]
    pub k_vs: ::prost::alloc::vec::Vec<KeyValue>,
    /// If set to true, do not wait for indexer to index ne entries
    #[prost(bool, tag = "2")]
    pub no_wait: bool,
    /// Preconditions to be met to perform the write
    #[prost(message, repeated, tag = "3")]
    pub preconditions: ::prost::alloc::vec::Vec<Precondition>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KeyRequest {
    /// Key to query for
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// If > 0, query for the value exactly at given transaction
    #[prost(uint64, tag = "2")]
    pub at_tx: u64,
    /// If 0 (and noWait=false), wait for the index to be up-to-date,
    /// If > 0 (and noWait=false), wait for at lest the sinceTx transaction to be indexed
    #[prost(uint64, tag = "3")]
    pub since_tx: u64,
    /// If set to true - do not wait for any indexing update considering only the currently indexed state
    #[prost(bool, tag = "4")]
    pub no_wait: bool,
    /// If > 0, get the nth version of the value, 1 being the first version, 2 being the second and so on
    /// If \< 0, get the historical nth value of the key, -1 being the previous version, -2 being the one before and so on
    #[prost(int64, tag = "5")]
    pub at_revision: i64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KeyListRequest {
    /// List of keys to query for
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// If 0, wait for index to be up-to-date,
    /// If > 0, wait for at least sinceTx transaction to be indexed
    #[prost(uint64, tag = "2")]
    pub since_tx: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteKeysRequest {
    /// List of keys to delete logically
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// If 0, wait for index to be up-to-date,
    /// If > 0, wait for at least sinceTx transaction to be indexed
    #[prost(uint64, tag = "2")]
    pub since_tx: u64,
    /// If set to true, do not wait for the indexer to index this operation
    #[prost(bool, tag = "3")]
    pub no_wait: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifiableSetRequest {
    /// Keys to set
    #[prost(message, optional, tag = "1")]
    pub set_request: ::core::option::Option<SetRequest>,
    /// When generating the proof, generate consistency proof with state from this transaction
    #[prost(uint64, tag = "2")]
    pub prove_since_tx: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VerifiableGetRequest {
    /// Key to read
    #[prost(message, optional, tag = "1")]
    pub key_request: ::core::option::Option<KeyRequest>,
    /// When generating the proof, generate consistency proof with state from this transaction
    #[prost(uint64, tag = "2")]
    pub prove_since_tx: u64,
}
/// ServerInfoRequest exists to provide extensibility for rpc ServerInfo.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServerInfoRequest {}
/// ServerInfoResponse contains information about the server instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServerInfoResponse {
    /// The version of the server instance.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// Unix timestamp (seconds) indicating when the server process has been started.
    #[prost(int64, tag = "2")]
    pub started_at: i64,
    /// Total number of transactions across all databases.
    #[prost(int64, tag = "3")]
    pub num_transactions: i64,
    /// Total number of databases present.
    #[prost(int32, tag = "4")]
    pub num_databases: i32,
    /// Total disk size used by all databases.
    #[prost(int64, tag = "5")]
    pub databases_disk_size: i64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HealthResponse {
    /// If true, server considers itself to be healthy
    #[prost(bool, tag = "1")]
    pub status: bool,
    /// The version of the server instance
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseHealthResponse {
    /// Number of requests currently being executed
    #[prost(uint32, tag = "1")]
    pub pending_requests: u32,
    /// Timestamp at which the last request was completed
    #[prost(int64, tag = "2")]
    pub last_request_completed_at: i64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImmutableState {
    /// The db name
    #[prost(string, tag = "1")]
    pub db: ::prost::alloc::string::String,
    /// Id of the most recent transaction
    #[prost(uint64, tag = "2")]
    pub tx_id: u64,
    /// State of the most recent transaction
    #[prost(bytes = "vec", tag = "3")]
    pub tx_hash: ::prost::alloc::vec::Vec<u8>,
    /// Signature of the hash
    #[prost(message, optional, tag = "4")]
    pub signature: ::core::option::Option<Signature>,
    /// Id of the most recent precommitted transaction
    #[prost(uint64, tag = "5")]
    pub precommitted_tx_id: u64,
    /// State of the most recent precommitted transaction
    #[prost(bytes = "vec", tag = "6")]
    pub precommitted_tx_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReferenceRequest {
    /// Key for the reference
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// Key to be referenced
    #[prost(bytes = "vec", tag = "2")]
    pub referenced_key: ::prost::alloc::vec::Vec<u8>,
    /// If boundRef == true, id of transaction to bind with the reference
    #[prost(uint64, tag = "3")]
    pub at_tx: u64,
    /// If true, bind the reference to particular transaction,
    /// if false, use the most recent value of the key
    #[prost(bool, tag = "4")]
    pub bound_ref: bool,
    /// If true, do not wait for the indexer to index this write operation
    #[prost(bool, tag = "5")]
    pub no_wait: bool,
    /// Preconditions to be met to perform the write
    #[prost(message, repeated, tag = "6")]
    pub preconditions: ::prost::alloc::vec::Vec<Precondition>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifiableReferenceRequest {
    /// Reference data
    #[prost(message, optional, tag = "1")]
    pub reference_request: ::core::option::Option<ReferenceRequest>,
    /// When generating the proof, generate consistency proof with state from this
    /// transaction
    #[prost(uint64, tag = "2")]
    pub prove_since_tx: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZAddRequest {
    /// Name of the sorted set
    #[prost(bytes = "vec", tag = "1")]
    pub set: ::prost::alloc::vec::Vec<u8>,
    /// Score of the new entry
    #[prost(double, tag = "2")]
    pub score: f64,
    /// Referenced key
    #[prost(bytes = "vec", tag = "3")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// If boundRef == true, id of the transaction to bind with the reference
    #[prost(uint64, tag = "4")]
    pub at_tx: u64,
    /// If true, bind the reference to particular transaction, if false, use the
    /// most recent value of the key
    #[prost(bool, tag = "5")]
    pub bound_ref: bool,
    /// If true, do not wait for the indexer to index this write operation
    #[prost(bool, tag = "6")]
    pub no_wait: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Score {
    /// Entry's score value
    #[prost(double, tag = "1")]
    pub score: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZScanRequest {
    /// Name of the sorted set
    #[prost(bytes = "vec", tag = "1")]
    pub set: ::prost::alloc::vec::Vec<u8>,
    /// Key to continue the search at
    #[prost(bytes = "vec", tag = "2")]
    pub seek_key: ::prost::alloc::vec::Vec<u8>,
    /// Score of the entry to continue the search at
    #[prost(double, tag = "3")]
    pub seek_score: f64,
    /// AtTx of the entry to continue the search at
    #[prost(uint64, tag = "4")]
    pub seek_at_tx: u64,
    /// If true, include the entry given with the `seekXXX` attributes, if false,
    /// skip the entry and start after that one
    #[prost(bool, tag = "5")]
    pub inclusive_seek: bool,
    /// Maximum number of entries to return, if 0, the default limit will be used
    #[prost(uint64, tag = "6")]
    pub limit: u64,
    /// If true, scan entries in descending order
    #[prost(bool, tag = "7")]
    pub desc: bool,
    /// Minimum score of entries to scan
    #[prost(message, optional, tag = "8")]
    pub min_score: ::core::option::Option<Score>,
    /// Maximum score of entries to scan
    #[prost(message, optional, tag = "9")]
    pub max_score: ::core::option::Option<Score>,
    /// If > 0, do not wait for the indexer to index all entries, only require
    /// entries up to sinceTx to be indexed
    #[prost(uint64, tag = "10")]
    pub since_tx: u64,
    /// Deprecated: If set to true, do not wait for the indexer to be up to date
    #[prost(bool, tag = "11")]
    pub no_wait: bool,
    /// Specify the index of initial entry to be returned by excluding the initial
    /// set of entries (alternative to seekXXX attributes)
    #[prost(uint64, tag = "12")]
    pub offset: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HistoryRequest {
    /// Name of the key to query for the history
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// Specify the initial entry to be returned by excluding the initial set of
    /// entries
    #[prost(uint64, tag = "2")]
    pub offset: u64,
    /// Maximum number of entries to return
    #[prost(int32, tag = "3")]
    pub limit: i32,
    /// If true, search in descending order
    #[prost(bool, tag = "4")]
    pub desc: bool,
    /// If > 0, do not wait for the indexer to index all entries, only require
    /// entries up to sinceTx to be indexed
    #[prost(uint64, tag = "5")]
    pub since_tx: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifiableZAddRequest {
    /// Data for new sorted set entry
    #[prost(message, optional, tag = "1")]
    pub z_add_request: ::core::option::Option<ZAddRequest>,
    /// When generating the proof, generate consistency proof with state from this transaction
    #[prost(uint64, tag = "2")]
    pub prove_since_tx: u64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TxRequest {
    /// Transaction id to query for
    #[prost(uint64, tag = "1")]
    pub tx: u64,
    /// Specification for parsing entries, if empty, entries are returned in raw form
    #[prost(message, optional, tag = "2")]
    pub entries_spec: ::core::option::Option<EntriesSpec>,
    /// If > 0, do not wait for the indexer to index all entries, only require
    /// entries up to sinceTx to be indexed, will affect resolving references
    #[prost(uint64, tag = "3")]
    pub since_tx: u64,
    /// Deprecated: If set to true, do not wait for the indexer to be up to date
    #[prost(bool, tag = "4")]
    pub no_wait: bool,
    /// If set to true, do not resolve references (avoid looking up final values if not needed)
    #[prost(bool, tag = "5")]
    pub keep_references_unresolved: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EntriesSpec {
    /// Specification for parsing KV entries
    #[prost(message, optional, tag = "1")]
    pub kv_entries_spec: ::core::option::Option<EntryTypeSpec>,
    /// Specification for parsing sorted set entries
    #[prost(message, optional, tag = "2")]
    pub z_entries_spec: ::core::option::Option<EntryTypeSpec>,
    /// Specification for parsing SQL entries
    #[prost(message, optional, tag = "3")]
    pub sql_entries_spec: ::core::option::Option<EntryTypeSpec>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EntryTypeSpec {
    /// Action to perform on entries
    #[prost(enumeration = "EntryTypeAction", tag = "1")]
    pub action: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VerifiableTxRequest {
    /// Transaction ID
    #[prost(uint64, tag = "1")]
    pub tx: u64,
    /// When generating the proof, generate consistency proof with state from this
    /// transaction
    #[prost(uint64, tag = "2")]
    pub prove_since_tx: u64,
    /// Specification of how to parse entries
    #[prost(message, optional, tag = "3")]
    pub entries_spec: ::core::option::Option<EntriesSpec>,
    /// If > 0, do not wait for the indexer to index all entries, only require
    /// entries up to sinceTx to be indexed, will affect resolving references
    #[prost(uint64, tag = "4")]
    pub since_tx: u64,
    /// Deprecated: If set to true, do not wait for the indexer to be up to date
    #[prost(bool, tag = "5")]
    pub no_wait: bool,
    /// If set to true, do not resolve references (avoid looking up final values if not needed)
    #[prost(bool, tag = "6")]
    pub keep_references_unresolved: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TxScanRequest {
    /// ID of the transaction where scanning should start
    #[prost(uint64, tag = "1")]
    pub initial_tx: u64,
    /// Maximum number of transactions to scan, when not specified the default limit is used
    #[prost(uint32, tag = "2")]
    pub limit: u32,
    /// If set to true, scan transactions in descending order
    #[prost(bool, tag = "3")]
    pub desc: bool,
    /// Specification of how to parse entries
    #[prost(message, optional, tag = "4")]
    pub entries_spec: ::core::option::Option<EntriesSpec>,
    /// If > 0, do not wait for the indexer to index all entries, only require
    /// entries up to sinceTx to be indexed, will affect resolving references
    #[prost(uint64, tag = "5")]
    pub since_tx: u64,
    /// Deprecated: If set to true, do not wait for the indexer to be up to date
    #[prost(bool, tag = "6")]
    pub no_wait: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxList {
    /// List of transactions
    #[prost(message, repeated, tag = "1")]
    pub txs: ::prost::alloc::vec::Vec<Tx>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExportTxRequest {
    /// Id of transaction to export
    #[prost(uint64, tag = "1")]
    pub tx: u64,
    /// If set to true, non-committed transactions can be exported
    #[prost(bool, tag = "2")]
    pub allow_pre_committed: bool,
    /// Used on synchronous replication to notify the primary about replica state
    #[prost(message, optional, tag = "3")]
    pub replica_state: ::core::option::Option<ReplicaState>,
    /// If set to true, integrity checks are skipped when reading data
    #[prost(bool, tag = "4")]
    pub skip_integrity_check: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReplicaState {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub committed_tx_id: u64,
    #[prost(bytes = "vec", tag = "3")]
    pub committed_alh: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub precommitted_tx_id: u64,
    #[prost(bytes = "vec", tag = "5")]
    pub precommitted_alh: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Database {
    /// Name of the database
    #[prost(string, tag = "1")]
    pub database_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseSettings {
    /// Name of the database
    #[prost(string, tag = "1")]
    pub database_name: ::prost::alloc::string::String,
    /// If set to true, this database is replicating another database
    #[prost(bool, tag = "2")]
    pub replica: bool,
    /// Name of the database to replicate
    #[prost(string, tag = "3")]
    pub primary_database: ::prost::alloc::string::String,
    /// Hostname of the immudb instance with database to replicate
    #[prost(string, tag = "4")]
    pub primary_host: ::prost::alloc::string::String,
    /// Port of the immudb instance with database to replicate
    #[prost(uint32, tag = "5")]
    pub primary_port: u32,
    /// Username of the user with read access of the database to replicate
    #[prost(string, tag = "6")]
    pub primary_username: ::prost::alloc::string::String,
    /// Password of the user with read access of the database to replicate
    #[prost(string, tag = "7")]
    pub primary_password: ::prost::alloc::string::String,
    /// Size of files stored on disk
    #[prost(uint32, tag = "8")]
    pub file_size: u32,
    /// Maximum length of keys
    #[prost(uint32, tag = "9")]
    pub max_key_len: u32,
    /// Maximum length of values
    #[prost(uint32, tag = "10")]
    pub max_value_len: u32,
    /// Maximum number of entries in a single transaction
    #[prost(uint32, tag = "11")]
    pub max_tx_entries: u32,
    /// If set to true, do not include commit timestamp in transaction headers
    #[prost(bool, tag = "12")]
    pub exclude_commit_time: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatabaseRequest {
    /// Database name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Database settings
    #[prost(message, optional, tag = "2")]
    pub settings: ::core::option::Option<DatabaseNullableSettings>,
    /// If set to true, do not fail if the database already exists
    #[prost(bool, tag = "3")]
    pub if_not_exists: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatabaseResponse {
    /// Database name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Current database settings
    #[prost(message, optional, tag = "2")]
    pub settings: ::core::option::Option<DatabaseNullableSettings>,
    /// Set to true if given database already existed
    #[prost(bool, tag = "3")]
    pub already_existed: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDatabaseRequest {
    /// Database name
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// Updated settings
    #[prost(message, optional, tag = "2")]
    pub settings: ::core::option::Option<DatabaseNullableSettings>,
}
/// Reserved to reply with more advanced response later
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDatabaseResponse {
    /// Database name
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// Current database settings
    #[prost(message, optional, tag = "2")]
    pub settings: ::core::option::Option<DatabaseNullableSettings>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseSettingsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseSettingsResponse {
    /// Database name
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// Database settings
    #[prost(message, optional, tag = "2")]
    pub settings: ::core::option::Option<DatabaseNullableSettings>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NullableUint32 {
    #[prost(uint32, tag = "1")]
    pub value: u32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NullableUint64 {
    #[prost(uint64, tag = "1")]
    pub value: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NullableFloat {
    #[prost(float, tag = "1")]
    pub value: f32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NullableBool {
    #[prost(bool, tag = "1")]
    pub value: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NullableString {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NullableMilliseconds {
    #[prost(int64, tag = "1")]
    pub value: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseNullableSettings {
    /// Replication settings
    #[prost(message, optional, tag = "2")]
    pub replication_settings: ::core::option::Option<ReplicationNullableSettings>,
    /// Max filesize on disk
    #[prost(message, optional, tag = "8")]
    pub file_size: ::core::option::Option<NullableUint32>,
    /// Maximum length of keys
    #[prost(message, optional, tag = "9")]
    pub max_key_len: ::core::option::Option<NullableUint32>,
    /// Maximum length of values
    #[prost(message, optional, tag = "10")]
    pub max_value_len: ::core::option::Option<NullableUint32>,
    /// Maximum number of entries in a single transaction
    #[prost(message, optional, tag = "11")]
    pub max_tx_entries: ::core::option::Option<NullableUint32>,
    /// If set to true, do not include commit timestamp in transaction headers
    #[prost(message, optional, tag = "12")]
    pub exclude_commit_time: ::core::option::Option<NullableBool>,
    /// Maximum number of simultaneous commits prepared for write
    #[prost(message, optional, tag = "13")]
    pub max_concurrency: ::core::option::Option<NullableUint32>,
    /// Maximum number of simultaneous IO writes
    #[prost(message, optional, tag = "14")]
    pub max_io_concurrency: ::core::option::Option<NullableUint32>,
    /// Size of the cache for transaction logs
    #[prost(message, optional, tag = "15")]
    pub tx_log_cache_size: ::core::option::Option<NullableUint32>,
    /// Maximum number of simultaneous value files opened
    #[prost(message, optional, tag = "16")]
    pub v_log_max_opened_files: ::core::option::Option<NullableUint32>,
    /// Maximum number of simultaneous transaction log files opened
    #[prost(message, optional, tag = "17")]
    pub tx_log_max_opened_files: ::core::option::Option<NullableUint32>,
    /// Maximum number of simultaneous commit log files opened
    #[prost(message, optional, tag = "18")]
    pub commit_log_max_opened_files: ::core::option::Option<NullableUint32>,
    /// Index settings
    #[prost(message, optional, tag = "19")]
    pub index_settings: ::core::option::Option<IndexNullableSettings>,
    /// Version of transaction header to use (limits available features)
    #[prost(message, optional, tag = "20")]
    pub write_tx_header_version: ::core::option::Option<NullableUint32>,
    /// If set to true, automatically load the database when starting immudb (true by default)
    #[prost(message, optional, tag = "21")]
    pub autoload: ::core::option::Option<NullableBool>,
    /// Size of the pool of read buffers
    #[prost(message, optional, tag = "22")]
    pub read_tx_pool_size: ::core::option::Option<NullableUint32>,
    /// Fsync frequency during commit process
    #[prost(message, optional, tag = "23")]
    pub sync_frequency: ::core::option::Option<NullableMilliseconds>,
    /// Size of the in-memory buffer for write operations
    #[prost(message, optional, tag = "24")]
    pub write_buffer_size: ::core::option::Option<NullableUint32>,
    /// Settings of Appendable Hash Tree
    #[prost(message, optional, tag = "25")]
    pub aht_settings: ::core::option::Option<AhtNullableSettings>,
    /// Maximum number of pre-committed transactions
    #[prost(message, optional, tag = "26")]
    pub max_active_transactions: ::core::option::Option<NullableUint32>,
    /// Limit the number of read entries per transaction
    #[prost(message, optional, tag = "27")]
    pub mvcc_read_set_limit: ::core::option::Option<NullableUint32>,
    /// Size of the cache for value logs
    #[prost(message, optional, tag = "28")]
    pub v_log_cache_size: ::core::option::Option<NullableUint32>,
    /// Truncation settings
    #[prost(message, optional, tag = "29")]
    pub truncation_settings: ::core::option::Option<TruncationNullableSettings>,
    /// If set to true, values are stored together with the transaction header (true by default)
    #[prost(message, optional, tag = "30")]
    pub embedded_values: ::core::option::Option<NullableBool>,
    /// Enable file preallocation
    #[prost(message, optional, tag = "31")]
    pub prealloc_files: ::core::option::Option<NullableBool>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReplicationNullableSettings {
    /// If set to true, this database is replicating another database
    #[prost(message, optional, tag = "1")]
    pub replica: ::core::option::Option<NullableBool>,
    /// Name of the database to replicate
    #[prost(message, optional, tag = "2")]
    pub primary_database: ::core::option::Option<NullableString>,
    /// Hostname of the immudb instance with database to replicate
    #[prost(message, optional, tag = "3")]
    pub primary_host: ::core::option::Option<NullableString>,
    /// Port of the immudb instance with database to replicate
    #[prost(message, optional, tag = "4")]
    pub primary_port: ::core::option::Option<NullableUint32>,
    /// Username of the user with read access of the database to replicate
    #[prost(message, optional, tag = "5")]
    pub primary_username: ::core::option::Option<NullableString>,
    /// Password of the user with read access of the database to replicate
    #[prost(message, optional, tag = "6")]
    pub primary_password: ::core::option::Option<NullableString>,
    /// Enable synchronous replication
    #[prost(message, optional, tag = "7")]
    pub sync_replication: ::core::option::Option<NullableBool>,
    /// Number of confirmations from synchronous replicas required to commit a transaction
    #[prost(message, optional, tag = "8")]
    pub sync_acks: ::core::option::Option<NullableUint32>,
    /// Maximum number of prefetched transactions
    #[prost(message, optional, tag = "9")]
    pub prefetch_tx_buffer_size: ::core::option::Option<NullableUint32>,
    /// Number of concurrent replications
    #[prost(message, optional, tag = "10")]
    pub replication_commit_concurrency: ::core::option::Option<NullableUint32>,
    /// Allow precommitted transactions to be discarded if the replica diverges from the primary
    #[prost(message, optional, tag = "11")]
    pub allow_tx_discarding: ::core::option::Option<NullableBool>,
    /// Disable integrity check when reading data during replication
    #[prost(message, optional, tag = "12")]
    pub skip_integrity_check: ::core::option::Option<NullableBool>,
    /// Wait for indexing to be up to date during replication
    #[prost(message, optional, tag = "13")]
    pub wait_for_indexing: ::core::option::Option<NullableBool>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TruncationNullableSettings {
    /// Retention Period for data in the database
    #[prost(message, optional, tag = "1")]
    pub retention_period: ::core::option::Option<NullableMilliseconds>,
    /// Truncation Frequency for the database
    #[prost(message, optional, tag = "2")]
    pub truncation_frequency: ::core::option::Option<NullableMilliseconds>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IndexNullableSettings {
    /// Number of new index entries between disk flushes
    #[prost(message, optional, tag = "1")]
    pub flush_threshold: ::core::option::Option<NullableUint32>,
    /// Number of new index entries between disk flushes with file sync
    #[prost(message, optional, tag = "2")]
    pub sync_threshold: ::core::option::Option<NullableUint32>,
    /// Size of the Btree node cache in bytes
    #[prost(message, optional, tag = "3")]
    pub cache_size: ::core::option::Option<NullableUint32>,
    /// Max size of a single Btree node in bytes
    #[prost(message, optional, tag = "4")]
    pub max_node_size: ::core::option::Option<NullableUint32>,
    /// Maximum number of active btree snapshots
    #[prost(message, optional, tag = "5")]
    pub max_active_snapshots: ::core::option::Option<NullableUint32>,
    /// Time in milliseconds between the most recent DB snapshot is automatically renewed
    #[prost(message, optional, tag = "6")]
    pub renew_snap_root_after: ::core::option::Option<NullableUint64>,
    /// Minimum number of updates entries in the btree to allow for full compaction
    #[prost(message, optional, tag = "7")]
    pub compaction_thld: ::core::option::Option<NullableUint32>,
    /// Additional delay added during indexing when full compaction is in progress
    #[prost(message, optional, tag = "8")]
    pub delay_during_compaction: ::core::option::Option<NullableUint32>,
    /// Maximum number of simultaneously opened nodes files
    #[prost(message, optional, tag = "9")]
    pub nodes_log_max_opened_files: ::core::option::Option<NullableUint32>,
    /// Maximum number of simultaneously opened node history files
    #[prost(message, optional, tag = "10")]
    pub history_log_max_opened_files: ::core::option::Option<NullableUint32>,
    /// Maximum number of simultaneously opened commit log files
    #[prost(message, optional, tag = "11")]
    pub commit_log_max_opened_files: ::core::option::Option<NullableUint32>,
    /// Size of the in-memory flush buffer (in bytes)
    #[prost(message, optional, tag = "12")]
    pub flush_buffer_size: ::core::option::Option<NullableUint32>,
    /// Percentage of node files cleaned up during each flush
    #[prost(message, optional, tag = "13")]
    pub cleanup_percentage: ::core::option::Option<NullableFloat>,
    /// Maximum number of transactions indexed together
    #[prost(message, optional, tag = "14")]
    pub max_bulk_size: ::core::option::Option<NullableUint32>,
    /// Maximum time waiting for more transactions to be committed and included into the same bulk
    #[prost(message, optional, tag = "15")]
    pub bulk_preparation_timeout: ::core::option::Option<NullableMilliseconds>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AhtNullableSettings {
    /// Number of new leaves in the tree between synchronous flush to disk
    #[prost(message, optional, tag = "1")]
    pub sync_threshold: ::core::option::Option<NullableUint32>,
    /// Size of the in-memory write buffer
    #[prost(message, optional, tag = "2")]
    pub write_buffer_size: ::core::option::Option<NullableUint32>,
}
/// Database name
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoadDatabaseRequest {
    /// may add createIfNotExist
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoadDatabaseResponse {
    /// Database name
    ///
    /// may add settings
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnloadDatabaseRequest {
    /// Database name
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnloadDatabaseResponse {
    /// Database name
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteDatabaseRequest {
    /// Database name
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteDatabaseResponse {
    /// Database name
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FlushIndexRequest {
    /// Percentage of nodes file to cleanup during flush
    #[prost(float, tag = "1")]
    pub cleanup_percentage: f32,
    /// If true, do a full disk sync after the flush
    #[prost(bool, tag = "2")]
    pub synced: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FlushIndexResponse {
    /// Database name
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Table {
    /// Table name
    #[prost(string, tag = "1")]
    pub table_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlGetRequest {
    /// Table name
    #[prost(string, tag = "1")]
    pub table: ::prost::alloc::string::String,
    /// Values of the primary key
    #[prost(message, repeated, tag = "2")]
    pub pk_values: ::prost::alloc::vec::Vec<SqlValue>,
    /// Id of the transaction at which the row was added / modified
    #[prost(uint64, tag = "3")]
    pub at_tx: u64,
    /// If > 0, do not wait for the indexer to index all entries, only require entries up to sinceTx to be indexed
    #[prost(uint64, tag = "4")]
    pub since_tx: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifiableSqlGetRequest {
    /// Data of row to query
    #[prost(message, optional, tag = "1")]
    pub sql_get_request: ::core::option::Option<SqlGetRequest>,
    /// When generating the proof, generate consistency proof with state from this transaction
    #[prost(uint64, tag = "2")]
    pub prove_since_tx: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlEntry {
    /// Id of the transaction when the row was added / modified
    #[prost(uint64, tag = "1")]
    pub tx: u64,
    /// Raw key of the row
    #[prost(bytes = "vec", tag = "2")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// Raw value of the row
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// Metadata of the raw value
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<KvMetadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifiableSqlEntry {
    /// Raw row entry data
    #[prost(message, optional, tag = "1")]
    pub sql_entry: ::core::option::Option<SqlEntry>,
    /// Verifiable transaction of the row
    #[prost(message, optional, tag = "2")]
    pub verifiable_tx: ::core::option::Option<VerifiableTx>,
    /// Inclusion proof of the row in the transaction
    #[prost(message, optional, tag = "3")]
    pub inclusion_proof: ::core::option::Option<InclusionProof>,
    /// Internal ID of the database (used to validate raw entry values)
    #[prost(uint32, tag = "4")]
    pub database_id: u32,
    /// Internal ID of the table (used to validate raw entry values)
    #[prost(uint32, tag = "5")]
    pub table_id: u32,
    /// Internal IDs of columns for the primary key (used to validate raw entry values)
    #[prost(uint32, repeated, tag = "16")]
    pub pki_ds: ::prost::alloc::vec::Vec<u32>,
    /// Mapping of used column IDs to their names
    #[prost(map = "uint32, string", tag = "8")]
    pub col_names_by_id: ::std::collections::HashMap<
        u32,
        ::prost::alloc::string::String,
    >,
    /// Mapping of column names to their IDS
    #[prost(map = "string, uint32", tag = "9")]
    pub col_ids_by_name: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        u32,
    >,
    /// Mapping of column IDs to their types
    #[prost(map = "uint32, string", tag = "10")]
    pub col_types_by_id: ::std::collections::HashMap<
        u32,
        ::prost::alloc::string::String,
    >,
    /// Mapping of column IDs to their length constraints
    #[prost(map = "uint32, int32", tag = "11")]
    pub col_len_by_id: ::std::collections::HashMap<u32, i32>,
    /// Variable is used to assign unique ids to new columns as they are created
    #[prost(uint32, tag = "12")]
    pub max_col_id: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UseDatabaseReply {
    /// Deprecated: database access token
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChangePermissionRequest {
    /// Action to perform
    #[prost(enumeration = "PermissionAction", tag = "1")]
    pub action: i32,
    /// Name of the user to update
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
    /// Name of the database
    #[prost(string, tag = "3")]
    pub database: ::prost::alloc::string::String,
    /// Permission to grant / revoke: 1 - read only, 2 - read/write, 254 - admin
    #[prost(uint32, tag = "4")]
    pub permission: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChangeSqlPrivilegesRequest {
    /// Action to perform
    #[prost(enumeration = "PermissionAction", tag = "1")]
    pub action: i32,
    /// Name of the user to update
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
    /// Name of the database
    #[prost(string, tag = "3")]
    pub database: ::prost::alloc::string::String,
    /// SQL privileges: SELECT, CREATE, INSERT, UPDATE, DELETE, DROP, ALTER
    #[prost(string, repeated, tag = "4")]
    pub privileges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChangeSqlPrivilegesResponse {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetActiveUserRequest {
    /// If true, the user is active
    #[prost(bool, tag = "1")]
    pub active: bool,
    /// Name of the user to activate / deactivate
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseListResponse {
    /// Database list
    #[prost(message, repeated, tag = "1")]
    pub databases: ::prost::alloc::vec::Vec<Database>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseListRequestV2 {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseListResponseV2 {
    /// Database list with current database settings
    #[prost(message, repeated, tag = "1")]
    pub databases: ::prost::alloc::vec::Vec<DatabaseInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseInfo {
    /// Database name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Current database settings
    #[prost(message, optional, tag = "2")]
    pub settings: ::core::option::Option<DatabaseNullableSettings>,
    /// If true, this database is currently loaded into memory
    #[prost(bool, tag = "3")]
    pub loaded: bool,
    /// database disk size
    #[prost(uint64, tag = "4")]
    pub disk_size: u64,
    /// total number of transactions
    #[prost(uint64, tag = "5")]
    pub num_transactions: u64,
    /// the time when the db was created
    #[prost(uint64, tag = "6")]
    pub created_at: u64,
    /// the user who created the database
    #[prost(string, tag = "7")]
    pub created_by: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chunk {
    #[prost(bytes = "vec", tag = "1")]
    pub content: ::prost::alloc::vec::Vec<u8>,
    #[prost(map = "string, bytes", tag = "2")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UseSnapshotRequest {
    #[prost(uint64, tag = "1")]
    pub since_tx: u64,
    #[prost(uint64, tag = "2")]
    pub as_before_tx: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlExecRequest {
    /// SQL query
    #[prost(string, tag = "1")]
    pub sql: ::prost::alloc::string::String,
    /// Named query parameters
    #[prost(message, repeated, tag = "2")]
    pub params: ::prost::alloc::vec::Vec<NamedParam>,
    /// If true, do not wait for the indexer to index written changes
    #[prost(bool, tag = "3")]
    pub no_wait: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlQueryRequest {
    /// SQL query
    #[prost(string, tag = "1")]
    pub sql: ::prost::alloc::string::String,
    /// Named query parameters
    #[prost(message, repeated, tag = "2")]
    pub params: ::prost::alloc::vec::Vec<NamedParam>,
    /// If true, reuse previously opened snapshot
    #[deprecated]
    #[prost(bool, tag = "3")]
    pub reuse_snapshot: bool,
    /// Wheter the client accepts a streaming response
    #[prost(bool, tag = "4")]
    pub accept_stream: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamedParam {
    /// Parameter name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Parameter value
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<SqlValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlExecResult {
    /// List of committed transactions as a result of the exec operation
    #[prost(message, repeated, tag = "5")]
    pub txs: ::prost::alloc::vec::Vec<CommittedSqlTx>,
    /// If true, there's an ongoing transaction after exec completes
    #[prost(bool, tag = "6")]
    pub ongoing_tx: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommittedSqlTx {
    /// Transaction header
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<TxHeader>,
    /// Number of updated rows
    #[prost(uint32, tag = "2")]
    pub updated_rows: u32,
    /// The value of last inserted auto_increment primary key (mapped by table name)
    #[prost(map = "string, message", tag = "3")]
    pub last_inserted_p_ks: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SqlValue,
    >,
    /// The value of first inserted auto_increment primary key (mapped by table name)
    #[prost(map = "string, message", tag = "4")]
    pub first_inserted_p_ks: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SqlValue,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlQueryResult {
    /// Result columns description
    #[prost(message, repeated, tag = "2")]
    pub columns: ::prost::alloc::vec::Vec<Column>,
    /// Result rows
    #[prost(message, repeated, tag = "1")]
    pub rows: ::prost::alloc::vec::Vec<Row>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Column {
    /// Column name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Column type
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Row {
    /// Column names
    #[prost(string, repeated, tag = "1")]
    pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Column values
    #[prost(message, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<SqlValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlValue {
    #[prost(oneof = "sql_value::Value", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub value: ::core::option::Option<sql_value::Value>,
}
/// Nested message and enum types in `SQLValue`.
pub mod sql_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(enumeration = "::prost_types::NullValue", tag = "1")]
        Null(i32),
        #[prost(int64, tag = "2")]
        N(i64),
        #[prost(string, tag = "3")]
        S(::prost::alloc::string::String),
        #[prost(bool, tag = "4")]
        B(bool),
        #[prost(bytes, tag = "5")]
        Bs(::prost::alloc::vec::Vec<u8>),
        #[prost(int64, tag = "6")]
        Ts(i64),
        #[prost(double, tag = "7")]
        F(f64),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NewTxRequest {
    /// Transaction mode
    #[prost(enumeration = "TxMode", tag = "1")]
    pub mode: i32,
    /// An existing snapshot may be reused as long as it includes the specified transaction
    /// If not specified it will include up to the latest precommitted transaction
    #[prost(message, optional, tag = "2")]
    pub snapshot_must_include_tx_id: ::core::option::Option<NullableUint64>,
    /// An existing snapshot may be reused as long as it is not older than the specified timeframe
    #[prost(message, optional, tag = "3")]
    pub snapshot_renewal_period: ::core::option::Option<NullableMilliseconds>,
    /// Indexing may not be up to date when doing MVCC
    #[prost(bool, tag = "4")]
    pub unsafe_mvcc: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NewTxResponse {
    /// Internal transaction ID
    #[prost(string, tag = "1")]
    pub transaction_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ErrorInfo {
    /// Error code
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    /// Error Description
    #[prost(string, tag = "2")]
    pub cause: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DebugInfo {
    /// Stack trace when the error was noticed
    #[prost(string, tag = "1")]
    pub stack: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RetryInfo {
    /// Number of milliseconds after which the request can be retried
    #[prost(int32, tag = "1")]
    pub retry_delay: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TruncateDatabaseRequest {
    /// Database name
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// Retention Period of data
    #[prost(int64, tag = "2")]
    pub retention_period: i64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TruncateDatabaseResponse {
    /// Database name
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EntryTypeAction {
    /// Exclude entries from the result
    Exclude = 0,
    /// Provide keys in raw (unparsed) form and only the digest of the value
    OnlyDigest = 1,
    /// Provide keys and values in raw form
    RawValue = 2,
    /// Provide parsed keys and values and resolve values if needed
    Resolve = 3,
}
impl EntryTypeAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Exclude => "EXCLUDE",
            Self::OnlyDigest => "ONLY_DIGEST",
            Self::RawValue => "RAW_VALUE",
            Self::Resolve => "RESOLVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXCLUDE" => Some(Self::Exclude),
            "ONLY_DIGEST" => Some(Self::OnlyDigest),
            "RAW_VALUE" => Some(Self::RawValue),
            "RESOLVE" => Some(Self::Resolve),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PermissionAction {
    /// Grant permission
    Grant = 0,
    /// Revoke permission
    Revoke = 1,
}
impl PermissionAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Grant => "GRANT",
            Self::Revoke => "REVOKE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GRANT" => Some(Self::Grant),
            "REVOKE" => Some(Self::Revoke),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TxMode {
    /// Read-only transaction
    ReadOnly = 0,
    /// Write-only transaction
    WriteOnly = 1,
    /// Read-write transaction
    ReadWrite = 2,
}
impl TxMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReadOnly => "ReadOnly",
            Self::WriteOnly => "WriteOnly",
            Self::ReadWrite => "ReadWrite",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ReadOnly" => Some(Self::ReadOnly),
            "WriteOnly" => Some(Self::WriteOnly),
            "ReadWrite" => Some(Self::ReadWrite),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod immu_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// immudb gRPC & REST service
    #[derive(Debug, Clone)]
    pub struct ImmuServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ImmuServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ImmuServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ImmuServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ImmuServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn list_users(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::UserList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/ListUsers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "ListUsers"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_user(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateUserRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/CreateUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "CreateUser"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn change_password(
            &mut self,
            request: impl tonic::IntoRequest<super::ChangePasswordRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/ChangePassword",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "ChangePassword"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn change_permission(
            &mut self,
            request: impl tonic::IntoRequest<super::ChangePermissionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/ChangePermission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "ChangePermission"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn change_sql_privileges(
            &mut self,
            request: impl tonic::IntoRequest<super::ChangeSqlPrivilegesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ChangeSqlPrivilegesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/ChangeSQLPrivileges",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "ChangeSQLPrivileges"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn set_active_user(
            &mut self,
            request: impl tonic::IntoRequest<super::SetActiveUserRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/SetActiveUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "SetActiveUser"));
            self.inner.unary(req, path, codec).await
        }
        #[deprecated]
        pub async fn update_auth_config(
            &mut self,
            request: impl tonic::IntoRequest<super::AuthConfig>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/UpdateAuthConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "UpdateAuthConfig"),
                );
            self.inner.unary(req, path, codec).await
        }
        #[deprecated]
        pub async fn update_mtls_config(
            &mut self,
            request: impl tonic::IntoRequest<super::MtlsConfig>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/UpdateMTLSConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "UpdateMTLSConfig"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn open_session(
            &mut self,
            request: impl tonic::IntoRequest<super::OpenSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OpenSessionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/OpenSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "OpenSession"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn close_session(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/CloseSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "CloseSession"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn keep_alive(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/KeepAlive",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "KeepAlive"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn new_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::NewTxRequest>,
        ) -> std::result::Result<tonic::Response<super::NewTxResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/NewTx",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "NewTx"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn commit(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::CommittedSqlTx>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/Commit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "Commit"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn rollback(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/Rollback",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "Rollback"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn tx_sql_exec(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlExecRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/TxSQLExec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "TxSQLExec"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn tx_sql_query(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlQueryRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SqlQueryResult>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/TxSQLQuery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "TxSQLQuery"));
            self.inner.server_streaming(req, path, codec).await
        }
        #[deprecated]
        pub async fn login(
            &mut self,
            request: impl tonic::IntoRequest<super::LoginRequest>,
        ) -> std::result::Result<tonic::Response<super::LoginResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/Login",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "Login"));
            self.inner.unary(req, path, codec).await
        }
        #[deprecated]
        pub async fn logout(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/Logout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "Logout"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn set(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRequest>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/Set",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "Set"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn verifiable_set(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifiableSetRequest>,
        ) -> std::result::Result<tonic::Response<super::VerifiableTx>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/VerifiableSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "VerifiableSet"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::KeyRequest>,
        ) -> std::result::Result<tonic::Response<super::Entry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "Get"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn verifiable_get(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifiableGetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VerifiableEntry>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/VerifiableGet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "VerifiableGet"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteKeysRequest>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_all(
            &mut self,
            request: impl tonic::IntoRequest<super::KeyListRequest>,
        ) -> std::result::Result<tonic::Response<super::Entries>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/GetAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "GetAll"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn exec_all(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecAllRequest>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/ExecAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "ExecAll"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn scan(
            &mut self,
            request: impl tonic::IntoRequest<super::ScanRequest>,
        ) -> std::result::Result<tonic::Response<super::Entries>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/Scan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "Scan"));
            self.inner.unary(req, path, codec).await
        }
        /// NOT YET SUPPORTED
        pub async fn count(
            &mut self,
            request: impl tonic::IntoRequest<super::KeyPrefix>,
        ) -> std::result::Result<tonic::Response<super::EntryCount>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/Count",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "Count"));
            self.inner.unary(req, path, codec).await
        }
        /// NOT YET SUPPORTED
        pub async fn count_all(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::EntryCount>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/CountAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "CountAll"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn tx_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::TxRequest>,
        ) -> std::result::Result<tonic::Response<super::Tx>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/TxById",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "TxById"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn verifiable_tx_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifiableTxRequest>,
        ) -> std::result::Result<tonic::Response<super::VerifiableTx>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/VerifiableTxById",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "VerifiableTxById"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn tx_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::TxScanRequest>,
        ) -> std::result::Result<tonic::Response<super::TxList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/TxScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "TxScan"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn history(
            &mut self,
            request: impl tonic::IntoRequest<super::HistoryRequest>,
        ) -> std::result::Result<tonic::Response<super::Entries>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/History",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "History"));
            self.inner.unary(req, path, codec).await
        }
        /// ServerInfo returns information about the server instance.
        /// ServerInfoRequest is defined for future extensions.
        pub async fn server_info(
            &mut self,
            request: impl tonic::IntoRequest<super::ServerInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ServerInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/ServerInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "ServerInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// DEPRECATED: Use ServerInfo
        pub async fn health(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::HealthResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/Health",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "Health"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn database_health(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::DatabaseHealthResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/DatabaseHealth",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "DatabaseHealth"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn current_state(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::ImmutableState>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/CurrentState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "CurrentState"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn set_reference(
            &mut self,
            request: impl tonic::IntoRequest<super::ReferenceRequest>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/SetReference",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "SetReference"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn verifiable_set_reference(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifiableReferenceRequest>,
        ) -> std::result::Result<tonic::Response<super::VerifiableTx>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/VerifiableSetReference",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "immudb.schema.ImmuService",
                        "VerifiableSetReference",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn z_add(
            &mut self,
            request: impl tonic::IntoRequest<super::ZAddRequest>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/ZAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "ZAdd"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn verifiable_z_add(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifiableZAddRequest>,
        ) -> std::result::Result<tonic::Response<super::VerifiableTx>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/VerifiableZAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "VerifiableZAdd"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn z_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::ZScanRequest>,
        ) -> std::result::Result<tonic::Response<super::ZEntries>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/ZScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "ZScan"));
            self.inner.unary(req, path, codec).await
        }
        /// DEPRECATED: Use CreateDatabaseV2
        #[deprecated]
        pub async fn create_database(
            &mut self,
            request: impl tonic::IntoRequest<super::Database>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/CreateDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "CreateDatabase"));
            self.inner.unary(req, path, codec).await
        }
        /// DEPRECATED: Use CreateDatabaseV2
        #[deprecated]
        pub async fn create_database_with(
            &mut self,
            request: impl tonic::IntoRequest<super::DatabaseSettings>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/CreateDatabaseWith",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "CreateDatabaseWith"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_database_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateDatabaseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/CreateDatabaseV2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "CreateDatabaseV2"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn load_database(
            &mut self,
            request: impl tonic::IntoRequest<super::LoadDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LoadDatabaseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/LoadDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "LoadDatabase"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn unload_database(
            &mut self,
            request: impl tonic::IntoRequest<super::UnloadDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnloadDatabaseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/UnloadDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "UnloadDatabase"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_database(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteDatabaseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/DeleteDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "DeleteDatabase"));
            self.inner.unary(req, path, codec).await
        }
        /// DEPRECATED: Use DatabaseListV2
        #[deprecated]
        pub async fn database_list(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::DatabaseListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/DatabaseList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "DatabaseList"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn database_list_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::DatabaseListRequestV2>,
        ) -> std::result::Result<
            tonic::Response<super::DatabaseListResponseV2>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/DatabaseListV2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "DatabaseListV2"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn use_database(
            &mut self,
            request: impl tonic::IntoRequest<super::Database>,
        ) -> std::result::Result<
            tonic::Response<super::UseDatabaseReply>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/UseDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "UseDatabase"));
            self.inner.unary(req, path, codec).await
        }
        /// DEPRECATED: Use UpdateDatabaseV2
        #[deprecated]
        pub async fn update_database(
            &mut self,
            request: impl tonic::IntoRequest<super::DatabaseSettings>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/UpdateDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "UpdateDatabase"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_database_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateDatabaseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/UpdateDatabaseV2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "UpdateDatabaseV2"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DEPRECATED: Use GetDatabaseSettingsV2
        #[deprecated]
        pub async fn get_database_settings(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<
            tonic::Response<super::DatabaseSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/GetDatabaseSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "GetDatabaseSettings"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_database_settings_v2(
            &mut self,
            request: impl tonic::IntoRequest<super::DatabaseSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DatabaseSettingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/GetDatabaseSettingsV2",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "GetDatabaseSettingsV2"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn flush_index(
            &mut self,
            request: impl tonic::IntoRequest<super::FlushIndexRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FlushIndexResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/FlushIndex",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "FlushIndex"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn compact_index(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/CompactIndex",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "CompactIndex"));
            self.inner.unary(req, path, codec).await
        }
        /// Streams
        pub async fn stream_get(
            &mut self,
            request: impl tonic::IntoRequest<super::KeyRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Chunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/streamGet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "streamGet"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn stream_set(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::Chunk>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/streamSet",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "streamSet"));
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn stream_verifiable_get(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifiableGetRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Chunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/streamVerifiableGet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "streamVerifiableGet"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn stream_verifiable_set(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::Chunk>,
        ) -> std::result::Result<tonic::Response<super::VerifiableTx>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/streamVerifiableSet",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "streamVerifiableSet"),
                );
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn stream_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::ScanRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Chunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/streamScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "streamScan"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn stream_z_scan(
            &mut self,
            request: impl tonic::IntoRequest<super::ZScanRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Chunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/streamZScan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "streamZScan"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn stream_history(
            &mut self,
            request: impl tonic::IntoRequest<super::HistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Chunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/streamHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "streamHistory"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn stream_exec_all(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::Chunk>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/streamExecAll",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "streamExecAll"));
            self.inner.client_streaming(req, path, codec).await
        }
        /// Replication
        pub async fn export_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportTxRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Chunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/exportTx",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "exportTx"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn replicate_tx(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::Chunk>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/replicateTx",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "replicateTx"));
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn stream_export_tx(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ExportTxRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Chunk>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/streamExportTx",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "streamExportTx"));
            self.inner.streaming(req, path, codec).await
        }
        pub async fn sql_exec(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlExecRequest>,
        ) -> std::result::Result<tonic::Response<super::SqlExecResult>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/SQLExec",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "SQLExec"));
            self.inner.unary(req, path, codec).await
        }
        /// For backward compatibility with the grpc-gateway API
        pub async fn unary_sql_query(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlQueryRequest>,
        ) -> std::result::Result<tonic::Response<super::SqlQueryResult>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/UnarySQLQuery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "UnarySQLQuery"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn sql_query(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlQueryRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SqlQueryResult>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/SQLQuery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "SQLQuery"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn list_tables(
            &mut self,
            request: impl tonic::IntoRequest<()>,
        ) -> std::result::Result<tonic::Response<super::SqlQueryResult>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/ListTables",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "ListTables"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn describe_table(
            &mut self,
            request: impl tonic::IntoRequest<super::Table>,
        ) -> std::result::Result<tonic::Response<super::SqlQueryResult>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/DescribeTable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("immudb.schema.ImmuService", "DescribeTable"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn verifiable_sql_get(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifiableSqlGetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VerifiableSqlEntry>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/VerifiableSQLGet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "VerifiableSQLGet"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn truncate_database(
            &mut self,
            request: impl tonic::IntoRequest<super::TruncateDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TruncateDatabaseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/immudb.schema.ImmuService/TruncateDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("immudb.schema.ImmuService", "TruncateDatabase"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod immu_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ImmuServiceServer.
    #[async_trait]
    pub trait ImmuService: std::marker::Send + std::marker::Sync + 'static {
        async fn list_users(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::UserList>, tonic::Status>;
        async fn create_user(
            &self,
            request: tonic::Request<super::CreateUserRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn change_password(
            &self,
            request: tonic::Request<super::ChangePasswordRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn change_permission(
            &self,
            request: tonic::Request<super::ChangePermissionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn change_sql_privileges(
            &self,
            request: tonic::Request<super::ChangeSqlPrivilegesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ChangeSqlPrivilegesResponse>,
            tonic::Status,
        >;
        async fn set_active_user(
            &self,
            request: tonic::Request<super::SetActiveUserRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn update_auth_config(
            &self,
            request: tonic::Request<super::AuthConfig>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn update_mtls_config(
            &self,
            request: tonic::Request<super::MtlsConfig>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn open_session(
            &self,
            request: tonic::Request<super::OpenSessionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OpenSessionResponse>,
            tonic::Status,
        >;
        async fn close_session(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn keep_alive(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn new_tx(
            &self,
            request: tonic::Request<super::NewTxRequest>,
        ) -> std::result::Result<tonic::Response<super::NewTxResponse>, tonic::Status>;
        async fn commit(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::CommittedSqlTx>, tonic::Status>;
        async fn rollback(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn tx_sql_exec(
            &self,
            request: tonic::Request<super::SqlExecRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Server streaming response type for the TxSQLQuery method.
        type TxSQLQueryStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::SqlQueryResult, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn tx_sql_query(
            &self,
            request: tonic::Request<super::SqlQueryRequest>,
        ) -> std::result::Result<tonic::Response<Self::TxSQLQueryStream>, tonic::Status>;
        async fn login(
            &self,
            request: tonic::Request<super::LoginRequest>,
        ) -> std::result::Result<tonic::Response<super::LoginResponse>, tonic::Status>;
        async fn logout(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn set(
            &self,
            request: tonic::Request<super::SetRequest>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status>;
        async fn verifiable_set(
            &self,
            request: tonic::Request<super::VerifiableSetRequest>,
        ) -> std::result::Result<tonic::Response<super::VerifiableTx>, tonic::Status>;
        async fn get(
            &self,
            request: tonic::Request<super::KeyRequest>,
        ) -> std::result::Result<tonic::Response<super::Entry>, tonic::Status>;
        async fn verifiable_get(
            &self,
            request: tonic::Request<super::VerifiableGetRequest>,
        ) -> std::result::Result<tonic::Response<super::VerifiableEntry>, tonic::Status>;
        async fn delete(
            &self,
            request: tonic::Request<super::DeleteKeysRequest>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status>;
        async fn get_all(
            &self,
            request: tonic::Request<super::KeyListRequest>,
        ) -> std::result::Result<tonic::Response<super::Entries>, tonic::Status>;
        async fn exec_all(
            &self,
            request: tonic::Request<super::ExecAllRequest>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status>;
        async fn scan(
            &self,
            request: tonic::Request<super::ScanRequest>,
        ) -> std::result::Result<tonic::Response<super::Entries>, tonic::Status>;
        /// NOT YET SUPPORTED
        async fn count(
            &self,
            request: tonic::Request<super::KeyPrefix>,
        ) -> std::result::Result<tonic::Response<super::EntryCount>, tonic::Status>;
        /// NOT YET SUPPORTED
        async fn count_all(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::EntryCount>, tonic::Status>;
        async fn tx_by_id(
            &self,
            request: tonic::Request<super::TxRequest>,
        ) -> std::result::Result<tonic::Response<super::Tx>, tonic::Status>;
        async fn verifiable_tx_by_id(
            &self,
            request: tonic::Request<super::VerifiableTxRequest>,
        ) -> std::result::Result<tonic::Response<super::VerifiableTx>, tonic::Status>;
        async fn tx_scan(
            &self,
            request: tonic::Request<super::TxScanRequest>,
        ) -> std::result::Result<tonic::Response<super::TxList>, tonic::Status>;
        async fn history(
            &self,
            request: tonic::Request<super::HistoryRequest>,
        ) -> std::result::Result<tonic::Response<super::Entries>, tonic::Status>;
        /// ServerInfo returns information about the server instance.
        /// ServerInfoRequest is defined for future extensions.
        async fn server_info(
            &self,
            request: tonic::Request<super::ServerInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ServerInfoResponse>,
            tonic::Status,
        >;
        /// DEPRECATED: Use ServerInfo
        async fn health(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::HealthResponse>, tonic::Status>;
        async fn database_health(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<
            tonic::Response<super::DatabaseHealthResponse>,
            tonic::Status,
        >;
        async fn current_state(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::ImmutableState>, tonic::Status>;
        async fn set_reference(
            &self,
            request: tonic::Request<super::ReferenceRequest>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status>;
        async fn verifiable_set_reference(
            &self,
            request: tonic::Request<super::VerifiableReferenceRequest>,
        ) -> std::result::Result<tonic::Response<super::VerifiableTx>, tonic::Status>;
        async fn z_add(
            &self,
            request: tonic::Request<super::ZAddRequest>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status>;
        async fn verifiable_z_add(
            &self,
            request: tonic::Request<super::VerifiableZAddRequest>,
        ) -> std::result::Result<tonic::Response<super::VerifiableTx>, tonic::Status>;
        async fn z_scan(
            &self,
            request: tonic::Request<super::ZScanRequest>,
        ) -> std::result::Result<tonic::Response<super::ZEntries>, tonic::Status>;
        /// DEPRECATED: Use CreateDatabaseV2
        async fn create_database(
            &self,
            request: tonic::Request<super::Database>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// DEPRECATED: Use CreateDatabaseV2
        async fn create_database_with(
            &self,
            request: tonic::Request<super::DatabaseSettings>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn create_database_v2(
            &self,
            request: tonic::Request<super::CreateDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateDatabaseResponse>,
            tonic::Status,
        >;
        async fn load_database(
            &self,
            request: tonic::Request<super::LoadDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LoadDatabaseResponse>,
            tonic::Status,
        >;
        async fn unload_database(
            &self,
            request: tonic::Request<super::UnloadDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnloadDatabaseResponse>,
            tonic::Status,
        >;
        async fn delete_database(
            &self,
            request: tonic::Request<super::DeleteDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteDatabaseResponse>,
            tonic::Status,
        >;
        /// DEPRECATED: Use DatabaseListV2
        async fn database_list(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<
            tonic::Response<super::DatabaseListResponse>,
            tonic::Status,
        >;
        async fn database_list_v2(
            &self,
            request: tonic::Request<super::DatabaseListRequestV2>,
        ) -> std::result::Result<
            tonic::Response<super::DatabaseListResponseV2>,
            tonic::Status,
        >;
        async fn use_database(
            &self,
            request: tonic::Request<super::Database>,
        ) -> std::result::Result<
            tonic::Response<super::UseDatabaseReply>,
            tonic::Status,
        >;
        /// DEPRECATED: Use UpdateDatabaseV2
        async fn update_database(
            &self,
            request: tonic::Request<super::DatabaseSettings>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        async fn update_database_v2(
            &self,
            request: tonic::Request<super::UpdateDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateDatabaseResponse>,
            tonic::Status,
        >;
        /// DEPRECATED: Use GetDatabaseSettingsV2
        async fn get_database_settings(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<
            tonic::Response<super::DatabaseSettings>,
            tonic::Status,
        >;
        async fn get_database_settings_v2(
            &self,
            request: tonic::Request<super::DatabaseSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DatabaseSettingsResponse>,
            tonic::Status,
        >;
        async fn flush_index(
            &self,
            request: tonic::Request<super::FlushIndexRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FlushIndexResponse>,
            tonic::Status,
        >;
        async fn compact_index(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status>;
        /// Server streaming response type for the streamGet method.
        type streamGetStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Chunk, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Streams
        async fn stream_get(
            &self,
            request: tonic::Request<super::KeyRequest>,
        ) -> std::result::Result<tonic::Response<Self::streamGetStream>, tonic::Status>;
        async fn stream_set(
            &self,
            request: tonic::Request<tonic::Streaming<super::Chunk>>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status>;
        /// Server streaming response type for the streamVerifiableGet method.
        type streamVerifiableGetStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Chunk, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn stream_verifiable_get(
            &self,
            request: tonic::Request<super::VerifiableGetRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::streamVerifiableGetStream>,
            tonic::Status,
        >;
        async fn stream_verifiable_set(
            &self,
            request: tonic::Request<tonic::Streaming<super::Chunk>>,
        ) -> std::result::Result<tonic::Response<super::VerifiableTx>, tonic::Status>;
        /// Server streaming response type for the streamScan method.
        type streamScanStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Chunk, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn stream_scan(
            &self,
            request: tonic::Request<super::ScanRequest>,
        ) -> std::result::Result<tonic::Response<Self::streamScanStream>, tonic::Status>;
        /// Server streaming response type for the streamZScan method.
        type streamZScanStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Chunk, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn stream_z_scan(
            &self,
            request: tonic::Request<super::ZScanRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::streamZScanStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the streamHistory method.
        type streamHistoryStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Chunk, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn stream_history(
            &self,
            request: tonic::Request<super::HistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::streamHistoryStream>,
            tonic::Status,
        >;
        async fn stream_exec_all(
            &self,
            request: tonic::Request<tonic::Streaming<super::Chunk>>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status>;
        /// Server streaming response type for the exportTx method.
        type exportTxStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Chunk, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Replication
        async fn export_tx(
            &self,
            request: tonic::Request<super::ExportTxRequest>,
        ) -> std::result::Result<tonic::Response<Self::exportTxStream>, tonic::Status>;
        async fn replicate_tx(
            &self,
            request: tonic::Request<tonic::Streaming<super::Chunk>>,
        ) -> std::result::Result<tonic::Response<super::TxHeader>, tonic::Status>;
        /// Server streaming response type for the streamExportTx method.
        type streamExportTxStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Chunk, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn stream_export_tx(
            &self,
            request: tonic::Request<tonic::Streaming<super::ExportTxRequest>>,
        ) -> std::result::Result<
            tonic::Response<Self::streamExportTxStream>,
            tonic::Status,
        >;
        async fn sql_exec(
            &self,
            request: tonic::Request<super::SqlExecRequest>,
        ) -> std::result::Result<tonic::Response<super::SqlExecResult>, tonic::Status>;
        /// For backward compatibility with the grpc-gateway API
        async fn unary_sql_query(
            &self,
            request: tonic::Request<super::SqlQueryRequest>,
        ) -> std::result::Result<tonic::Response<super::SqlQueryResult>, tonic::Status>;
        /// Server streaming response type for the SQLQuery method.
        type SQLQueryStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::SqlQueryResult, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn sql_query(
            &self,
            request: tonic::Request<super::SqlQueryRequest>,
        ) -> std::result::Result<tonic::Response<Self::SQLQueryStream>, tonic::Status>;
        async fn list_tables(
            &self,
            request: tonic::Request<()>,
        ) -> std::result::Result<tonic::Response<super::SqlQueryResult>, tonic::Status>;
        async fn describe_table(
            &self,
            request: tonic::Request<super::Table>,
        ) -> std::result::Result<tonic::Response<super::SqlQueryResult>, tonic::Status>;
        async fn verifiable_sql_get(
            &self,
            request: tonic::Request<super::VerifiableSqlGetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VerifiableSqlEntry>,
            tonic::Status,
        >;
        async fn truncate_database(
            &self,
            request: tonic::Request<super::TruncateDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TruncateDatabaseResponse>,
            tonic::Status,
        >;
    }
    /// immudb gRPC & REST service
    #[derive(Debug)]
    pub struct ImmuServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ImmuServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ImmuServiceServer<T>
    where
        T: ImmuService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/immudb.schema.ImmuService/ListUsers" => {
                    #[allow(non_camel_case_types)]
                    struct ListUsersSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for ListUsersSvc<T> {
                        type Response = super::UserList;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::list_users(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListUsersSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/CreateUser" => {
                    #[allow(non_camel_case_types)]
                    struct CreateUserSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::CreateUserRequest>
                    for CreateUserSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateUserRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::create_user(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateUserSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/ChangePassword" => {
                    #[allow(non_camel_case_types)]
                    struct ChangePasswordSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::ChangePasswordRequest>
                    for ChangePasswordSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ChangePasswordRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::change_password(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ChangePasswordSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/ChangePermission" => {
                    #[allow(non_camel_case_types)]
                    struct ChangePermissionSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::ChangePermissionRequest>
                    for ChangePermissionSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ChangePermissionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::change_permission(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ChangePermissionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/ChangeSQLPrivileges" => {
                    #[allow(non_camel_case_types)]
                    struct ChangeSQLPrivilegesSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::ChangeSqlPrivilegesRequest>
                    for ChangeSQLPrivilegesSvc<T> {
                        type Response = super::ChangeSqlPrivilegesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ChangeSqlPrivilegesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::change_sql_privileges(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ChangeSQLPrivilegesSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/SetActiveUser" => {
                    #[allow(non_camel_case_types)]
                    struct SetActiveUserSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::SetActiveUserRequest>
                    for SetActiveUserSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetActiveUserRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::set_active_user(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetActiveUserSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/UpdateAuthConfig" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateAuthConfigSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::AuthConfig>
                    for UpdateAuthConfigSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AuthConfig>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::update_auth_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateAuthConfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/UpdateMTLSConfig" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateMTLSConfigSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::MtlsConfig>
                    for UpdateMTLSConfigSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MtlsConfig>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::update_mtls_config(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateMTLSConfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/OpenSession" => {
                    #[allow(non_camel_case_types)]
                    struct OpenSessionSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::OpenSessionRequest>
                    for OpenSessionSvc<T> {
                        type Response = super::OpenSessionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::OpenSessionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::open_session(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = OpenSessionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/CloseSession" => {
                    #[allow(non_camel_case_types)]
                    struct CloseSessionSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for CloseSessionSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::close_session(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CloseSessionSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/KeepAlive" => {
                    #[allow(non_camel_case_types)]
                    struct KeepAliveSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for KeepAliveSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::keep_alive(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = KeepAliveSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/NewTx" => {
                    #[allow(non_camel_case_types)]
                    struct NewTxSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::NewTxRequest>
                    for NewTxSvc<T> {
                        type Response = super::NewTxResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::NewTxRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::new_tx(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = NewTxSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/Commit" => {
                    #[allow(non_camel_case_types)]
                    struct CommitSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for CommitSvc<T> {
                        type Response = super::CommittedSqlTx;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::commit(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CommitSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/Rollback" => {
                    #[allow(non_camel_case_types)]
                    struct RollbackSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for RollbackSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::rollback(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RollbackSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/TxSQLExec" => {
                    #[allow(non_camel_case_types)]
                    struct TxSQLExecSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::SqlExecRequest>
                    for TxSQLExecSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SqlExecRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::tx_sql_exec(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TxSQLExecSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/TxSQLQuery" => {
                    #[allow(non_camel_case_types)]
                    struct TxSQLQuerySvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::ServerStreamingService<super::SqlQueryRequest>
                    for TxSQLQuerySvc<T> {
                        type Response = super::SqlQueryResult;
                        type ResponseStream = T::TxSQLQueryStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SqlQueryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::tx_sql_query(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TxSQLQuerySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/Login" => {
                    #[allow(non_camel_case_types)]
                    struct LoginSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::LoginRequest>
                    for LoginSvc<T> {
                        type Response = super::LoginResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LoginRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::login(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LoginSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/Logout" => {
                    #[allow(non_camel_case_types)]
                    struct LogoutSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for LogoutSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::logout(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LogoutSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/Set" => {
                    #[allow(non_camel_case_types)]
                    struct SetSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::SetRequest>
                    for SetSvc<T> {
                        type Response = super::TxHeader;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::set(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/VerifiableSet" => {
                    #[allow(non_camel_case_types)]
                    struct VerifiableSetSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::VerifiableSetRequest>
                    for VerifiableSetSvc<T> {
                        type Response = super::VerifiableTx;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VerifiableSetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::verifiable_set(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VerifiableSetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/Get" => {
                    #[allow(non_camel_case_types)]
                    struct GetSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::KeyRequest>
                    for GetSvc<T> {
                        type Response = super::Entry;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::KeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::get(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/VerifiableGet" => {
                    #[allow(non_camel_case_types)]
                    struct VerifiableGetSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::VerifiableGetRequest>
                    for VerifiableGetSvc<T> {
                        type Response = super::VerifiableEntry;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VerifiableGetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::verifiable_get(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VerifiableGetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/Delete" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::DeleteKeysRequest>
                    for DeleteSvc<T> {
                        type Response = super::TxHeader;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteKeysRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::delete(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/GetAll" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::KeyListRequest>
                    for GetAllSvc<T> {
                        type Response = super::Entries;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::KeyListRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::get_all(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAllSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/ExecAll" => {
                    #[allow(non_camel_case_types)]
                    struct ExecAllSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::ExecAllRequest>
                    for ExecAllSvc<T> {
                        type Response = super::TxHeader;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecAllRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::exec_all(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecAllSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/Scan" => {
                    #[allow(non_camel_case_types)]
                    struct ScanSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::ScanRequest>
                    for ScanSvc<T> {
                        type Response = super::Entries;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ScanRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::scan(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ScanSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/Count" => {
                    #[allow(non_camel_case_types)]
                    struct CountSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::KeyPrefix>
                    for CountSvc<T> {
                        type Response = super::EntryCount;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::KeyPrefix>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::count(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CountSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/CountAll" => {
                    #[allow(non_camel_case_types)]
                    struct CountAllSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for CountAllSvc<T> {
                        type Response = super::EntryCount;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::count_all(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CountAllSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/TxById" => {
                    #[allow(non_camel_case_types)]
                    struct TxByIdSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::TxRequest>
                    for TxByIdSvc<T> {
                        type Response = super::Tx;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TxRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::tx_by_id(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TxByIdSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/VerifiableTxById" => {
                    #[allow(non_camel_case_types)]
                    struct VerifiableTxByIdSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::VerifiableTxRequest>
                    for VerifiableTxByIdSvc<T> {
                        type Response = super::VerifiableTx;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VerifiableTxRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::verifiable_tx_by_id(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VerifiableTxByIdSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/TxScan" => {
                    #[allow(non_camel_case_types)]
                    struct TxScanSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::TxScanRequest>
                    for TxScanSvc<T> {
                        type Response = super::TxList;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TxScanRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::tx_scan(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TxScanSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/History" => {
                    #[allow(non_camel_case_types)]
                    struct HistorySvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::HistoryRequest>
                    for HistorySvc<T> {
                        type Response = super::Entries;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HistoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::history(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HistorySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/ServerInfo" => {
                    #[allow(non_camel_case_types)]
                    struct ServerInfoSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::ServerInfoRequest>
                    for ServerInfoSvc<T> {
                        type Response = super::ServerInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ServerInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::server_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ServerInfoSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/Health" => {
                    #[allow(non_camel_case_types)]
                    struct HealthSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for HealthSvc<T> {
                        type Response = super::HealthResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::health(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HealthSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/DatabaseHealth" => {
                    #[allow(non_camel_case_types)]
                    struct DatabaseHealthSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for DatabaseHealthSvc<T> {
                        type Response = super::DatabaseHealthResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::database_health(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DatabaseHealthSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/CurrentState" => {
                    #[allow(non_camel_case_types)]
                    struct CurrentStateSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for CurrentStateSvc<T> {
                        type Response = super::ImmutableState;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::current_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CurrentStateSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/SetReference" => {
                    #[allow(non_camel_case_types)]
                    struct SetReferenceSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::ReferenceRequest>
                    for SetReferenceSvc<T> {
                        type Response = super::TxHeader;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReferenceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::set_reference(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SetReferenceSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/VerifiableSetReference" => {
                    #[allow(non_camel_case_types)]
                    struct VerifiableSetReferenceSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::VerifiableReferenceRequest>
                    for VerifiableSetReferenceSvc<T> {
                        type Response = super::VerifiableTx;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VerifiableReferenceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::verifiable_set_reference(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VerifiableSetReferenceSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/ZAdd" => {
                    #[allow(non_camel_case_types)]
                    struct ZAddSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::ZAddRequest>
                    for ZAddSvc<T> {
                        type Response = super::TxHeader;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ZAddRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::z_add(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ZAddSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/VerifiableZAdd" => {
                    #[allow(non_camel_case_types)]
                    struct VerifiableZAddSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::VerifiableZAddRequest>
                    for VerifiableZAddSvc<T> {
                        type Response = super::VerifiableTx;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VerifiableZAddRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::verifiable_z_add(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VerifiableZAddSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/ZScan" => {
                    #[allow(non_camel_case_types)]
                    struct ZScanSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::ZScanRequest>
                    for ZScanSvc<T> {
                        type Response = super::ZEntries;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ZScanRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::z_scan(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ZScanSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/CreateDatabase" => {
                    #[allow(non_camel_case_types)]
                    struct CreateDatabaseSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::Database>
                    for CreateDatabaseSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Database>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::create_database(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateDatabaseSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/CreateDatabaseWith" => {
                    #[allow(non_camel_case_types)]
                    struct CreateDatabaseWithSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::DatabaseSettings>
                    for CreateDatabaseWithSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DatabaseSettings>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::create_database_with(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateDatabaseWithSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/CreateDatabaseV2" => {
                    #[allow(non_camel_case_types)]
                    struct CreateDatabaseV2Svc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::CreateDatabaseRequest>
                    for CreateDatabaseV2Svc<T> {
                        type Response = super::CreateDatabaseResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateDatabaseRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::create_database_v2(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateDatabaseV2Svc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/LoadDatabase" => {
                    #[allow(non_camel_case_types)]
                    struct LoadDatabaseSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::LoadDatabaseRequest>
                    for LoadDatabaseSvc<T> {
                        type Response = super::LoadDatabaseResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LoadDatabaseRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::load_database(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LoadDatabaseSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/UnloadDatabase" => {
                    #[allow(non_camel_case_types)]
                    struct UnloadDatabaseSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::UnloadDatabaseRequest>
                    for UnloadDatabaseSvc<T> {
                        type Response = super::UnloadDatabaseResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnloadDatabaseRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::unload_database(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnloadDatabaseSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/DeleteDatabase" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteDatabaseSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::DeleteDatabaseRequest>
                    for DeleteDatabaseSvc<T> {
                        type Response = super::DeleteDatabaseResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteDatabaseRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::delete_database(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteDatabaseSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/DatabaseList" => {
                    #[allow(non_camel_case_types)]
                    struct DatabaseListSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for DatabaseListSvc<T> {
                        type Response = super::DatabaseListResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::database_list(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DatabaseListSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/DatabaseListV2" => {
                    #[allow(non_camel_case_types)]
                    struct DatabaseListV2Svc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::DatabaseListRequestV2>
                    for DatabaseListV2Svc<T> {
                        type Response = super::DatabaseListResponseV2;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DatabaseListRequestV2>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::database_list_v2(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DatabaseListV2Svc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/UseDatabase" => {
                    #[allow(non_camel_case_types)]
                    struct UseDatabaseSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::Database>
                    for UseDatabaseSvc<T> {
                        type Response = super::UseDatabaseReply;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Database>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::use_database(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UseDatabaseSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/UpdateDatabase" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateDatabaseSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::DatabaseSettings>
                    for UpdateDatabaseSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DatabaseSettings>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::update_database(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateDatabaseSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/UpdateDatabaseV2" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateDatabaseV2Svc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::UpdateDatabaseRequest>
                    for UpdateDatabaseV2Svc<T> {
                        type Response = super::UpdateDatabaseResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateDatabaseRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::update_database_v2(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateDatabaseV2Svc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/GetDatabaseSettings" => {
                    #[allow(non_camel_case_types)]
                    struct GetDatabaseSettingsSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for GetDatabaseSettingsSvc<T> {
                        type Response = super::DatabaseSettings;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::get_database_settings(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDatabaseSettingsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/GetDatabaseSettingsV2" => {
                    #[allow(non_camel_case_types)]
                    struct GetDatabaseSettingsV2Svc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::DatabaseSettingsRequest>
                    for GetDatabaseSettingsV2Svc<T> {
                        type Response = super::DatabaseSettingsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DatabaseSettingsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::get_database_settings_v2(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetDatabaseSettingsV2Svc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/FlushIndex" => {
                    #[allow(non_camel_case_types)]
                    struct FlushIndexSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::FlushIndexRequest>
                    for FlushIndexSvc<T> {
                        type Response = super::FlushIndexResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FlushIndexRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::flush_index(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FlushIndexSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/CompactIndex" => {
                    #[allow(non_camel_case_types)]
                    struct CompactIndexSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for CompactIndexSvc<T> {
                        type Response = ();
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::compact_index(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CompactIndexSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/streamGet" => {
                    #[allow(non_camel_case_types)]
                    struct streamGetSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::ServerStreamingService<super::KeyRequest>
                    for streamGetSvc<T> {
                        type Response = super::Chunk;
                        type ResponseStream = T::streamGetStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::KeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::stream_get(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = streamGetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/streamSet" => {
                    #[allow(non_camel_case_types)]
                    struct streamSetSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::ClientStreamingService<super::Chunk>
                    for streamSetSvc<T> {
                        type Response = super::TxHeader;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::Chunk>>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::stream_set(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = streamSetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/streamVerifiableGet" => {
                    #[allow(non_camel_case_types)]
                    struct streamVerifiableGetSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::ServerStreamingService<super::VerifiableGetRequest>
                    for streamVerifiableGetSvc<T> {
                        type Response = super::Chunk;
                        type ResponseStream = T::streamVerifiableGetStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VerifiableGetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::stream_verifiable_get(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = streamVerifiableGetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/streamVerifiableSet" => {
                    #[allow(non_camel_case_types)]
                    struct streamVerifiableSetSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::ClientStreamingService<super::Chunk>
                    for streamVerifiableSetSvc<T> {
                        type Response = super::VerifiableTx;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::Chunk>>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::stream_verifiable_set(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = streamVerifiableSetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/streamScan" => {
                    #[allow(non_camel_case_types)]
                    struct streamScanSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::ServerStreamingService<super::ScanRequest>
                    for streamScanSvc<T> {
                        type Response = super::Chunk;
                        type ResponseStream = T::streamScanStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ScanRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::stream_scan(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = streamScanSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/streamZScan" => {
                    #[allow(non_camel_case_types)]
                    struct streamZScanSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::ServerStreamingService<super::ZScanRequest>
                    for streamZScanSvc<T> {
                        type Response = super::Chunk;
                        type ResponseStream = T::streamZScanStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ZScanRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::stream_z_scan(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = streamZScanSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/streamHistory" => {
                    #[allow(non_camel_case_types)]
                    struct streamHistorySvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::ServerStreamingService<super::HistoryRequest>
                    for streamHistorySvc<T> {
                        type Response = super::Chunk;
                        type ResponseStream = T::streamHistoryStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HistoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::stream_history(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = streamHistorySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/streamExecAll" => {
                    #[allow(non_camel_case_types)]
                    struct streamExecAllSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::ClientStreamingService<super::Chunk>
                    for streamExecAllSvc<T> {
                        type Response = super::TxHeader;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::Chunk>>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::stream_exec_all(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = streamExecAllSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/exportTx" => {
                    #[allow(non_camel_case_types)]
                    struct exportTxSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::ServerStreamingService<super::ExportTxRequest>
                    for exportTxSvc<T> {
                        type Response = super::Chunk;
                        type ResponseStream = T::exportTxStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExportTxRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::export_tx(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = exportTxSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/replicateTx" => {
                    #[allow(non_camel_case_types)]
                    struct replicateTxSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::ClientStreamingService<super::Chunk>
                    for replicateTxSvc<T> {
                        type Response = super::TxHeader;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::Chunk>>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::replicate_tx(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = replicateTxSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/streamExportTx" => {
                    #[allow(non_camel_case_types)]
                    struct streamExportTxSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::StreamingService<super::ExportTxRequest>
                    for streamExportTxSvc<T> {
                        type Response = super::Chunk;
                        type ResponseStream = T::streamExportTxStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::ExportTxRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::stream_export_tx(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = streamExportTxSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/SQLExec" => {
                    #[allow(non_camel_case_types)]
                    struct SQLExecSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::SqlExecRequest>
                    for SQLExecSvc<T> {
                        type Response = super::SqlExecResult;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SqlExecRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::sql_exec(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SQLExecSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/UnarySQLQuery" => {
                    #[allow(non_camel_case_types)]
                    struct UnarySQLQuerySvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::SqlQueryRequest>
                    for UnarySQLQuerySvc<T> {
                        type Response = super::SqlQueryResult;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SqlQueryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::unary_sql_query(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnarySQLQuerySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/SQLQuery" => {
                    #[allow(non_camel_case_types)]
                    struct SQLQuerySvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::ServerStreamingService<super::SqlQueryRequest>
                    for SQLQuerySvc<T> {
                        type Response = super::SqlQueryResult;
                        type ResponseStream = T::SQLQueryStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SqlQueryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::sql_query(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SQLQuerySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/ListTables" => {
                    #[allow(non_camel_case_types)]
                    struct ListTablesSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<()>
                    for ListTablesSvc<T> {
                        type Response = super::SqlQueryResult;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(&mut self, request: tonic::Request<()>) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::list_tables(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListTablesSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/DescribeTable" => {
                    #[allow(non_camel_case_types)]
                    struct DescribeTableSvc<T: ImmuService>(pub Arc<T>);
                    impl<T: ImmuService> tonic::server::UnaryService<super::Table>
                    for DescribeTableSvc<T> {
                        type Response = super::SqlQueryResult;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Table>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::describe_table(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DescribeTableSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/VerifiableSQLGet" => {
                    #[allow(non_camel_case_types)]
                    struct VerifiableSQLGetSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::VerifiableSqlGetRequest>
                    for VerifiableSQLGetSvc<T> {
                        type Response = super::VerifiableSqlEntry;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VerifiableSqlGetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::verifiable_sql_get(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VerifiableSQLGetSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/immudb.schema.ImmuService/TruncateDatabase" => {
                    #[allow(non_camel_case_types)]
                    struct TruncateDatabaseSvc<T: ImmuService>(pub Arc<T>);
                    impl<
                        T: ImmuService,
                    > tonic::server::UnaryService<super::TruncateDatabaseRequest>
                    for TruncateDatabaseSvc<T> {
                        type Response = super::TruncateDatabaseResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TruncateDatabaseRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImmuService>::truncate_database(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TruncateDatabaseSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ImmuServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "immudb.schema.ImmuService";
    impl<T> tonic::server::NamedService for ImmuServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
